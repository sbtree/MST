unit BootTesterMain;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Serial3,ExtCtrls, {CPort, CPortCtl,} RegExpr, ComCtrls;

type
  EBootState = (
                BS_UNKNOWN,
                BS_ORIGIN,
                BS_MTXSRV,
                BS_MTXAPP
                );

  TFrmBootTester = class(TForm)
    memRecv: TMemo;
    btnClear: TButton;
    btnExport: TButton;
    grpRS232: TGroupBox;
    lblPort: TLabel;
    cmbPort: TComboBox;
    lblBaudrate: TLabel;
    cmbBaudrate: TComboBox;
    btnClose: TButton;
    chkXonXoff: TCheckBox;
    Label1: TLabel;
    grpSendCommand: TGroupBox;
    lblLoop: TLabel;
    btnSend: TButton;
    txtSend: TEdit;
    chbRecv: TCheckBox;
    txtLoop: TEdit;
    lstSending: TListBox;
    chbVerify: TCheckBox;
    txtVerify: TEdit;
    grpService: TGroupBox;
    btnReset: TButton;
    cmbTo: TComboBox;
    btnSendFile: TButton;
    txtFile: TEdit;
    btnFile: TButton;
    pgbSendFile: TProgressBar;
    lblSendFile: TLabel;
    chkMetronix: TCheckBox;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    //procedure ComPortRxChar(Sender: TObject; Count: Integer);
    procedure cmbPortChange(Sender: TObject);
    procedure cmbBaudrateChange(Sender: TObject);
    procedure btnSendClick(Sender: TObject);
    procedure btnClearClick(Sender: TObject);
    procedure btnExportClick(Sender: TObject);
    procedure lstSendingDblClick(Sender: TObject);
    procedure chbRecvClick(Sender: TObject);
    procedure chbVerifyClick(Sender: TObject);
    procedure txtVerifyEnter(Sender: TObject);
    procedure btnResetClick(Sender: TObject);
    procedure btnCloseClick(Sender: TObject);
    procedure btnFileClick(Sender: TObject);
    procedure btnSendFileClick(Sender: TObject);
    procedure chkXonXoffClick(Sender: TObject);
  protected
    procedure Transmit();
    function SendStr(const str: string): integer;
    function RecvStr(var str:string): integer;
    function BootState(): EBootState;
    function ExpectStr(const str: string; var sRecv: string; const msecs: cardinal): boolean;

  private
    { Private-Deklarationen }
    t_ser: TSerial;
    c_timeout: cardinal;
  public
    { Public-Deklarationen }
  end;

var
  FrmBootTester: TFrmBootTester;

implementation

{$R *.dfm}
uses StrUtils;
const
  C_DELAY_MSEC: Cardinal = 50;
  CSTR_FORMAT_TO : string = '%0.3f--------- ---------- ---------- ---------->';
  CSTR_FORMAT_FROM : string = '%0.3f<--------- ---------- ---------- ----------';

procedure Delay(const msec: cardinal);
var i_timeout: cardinal;
begin
  i_timeout := GetTickCount() + msec;
  repeat Application.ProcessMessages();
  until (GetTickCount() >= i_timeout);
end;

{procedure TForm1.ComPortRxChar(Sender: TObject; Count: Integer);
var
  Str: String;
begin
  t_comport.ReadStr(Str, Count);
  i_timeout := GetTickCount() - i_timeout;
  memRecv.Lines.Add(format('%0.3f:<%s',[i_timeout/1000, Str]));
  i_timeout := GetTickCount();
end;}

procedure TFrmBootTester.btnClearClick(Sender: TObject);
begin
  memRecv.Lines.Clear();
end;

procedure TFrmBootTester.btnCloseClick(Sender: TObject);
var a: array[-1..5] of char;
begin
  t_ser.Active := false;
end;

procedure TFrmBootTester.Transmit();
var i_tstart, i_tend: cardinal; s_buffer: string; i: integer; t_cmds:TStringList;
    t_regex: TRegExpr; s_tmp: string;
begin
  s_buffer := trim(txtSend.Text);
  s_buffer := StringReplace(s_buffer, '<CR>', Char(13),[rfReplaceAll, rfIgnoreCase]) + Char(13);
  t_cmds := TStringList.create;
  ExtractStrings([Char(13)], [], PChar(s_buffer), t_cmds);
  for i := 0 to t_cmds.Count - 1 do
  begin
    i_tstart := GetTickCount();
    SendStr(t_cmds[i] + Char(13));
    i_tend := GetTickCount();
    memRecv.Lines.Add(format('%0.3f:>%s',[(i_tend - i_tstart)/1000, t_cmds[i]]));
  end;
  {i_timeout := GetTickCount();}
  if chbRecv.Checked then
  begin
    s_buffer := '';
    i_tstart := GetTickCount();
    RecvStr(s_buffer);
    i_tend := GetTickCount();
    if (chbVerify.Checked and (trim(txtVerify.Text)<>'')) then
    begin
      t_regex := TRegExpr.Create;
      t_regex.Expression := trim(txtVerify.Text);
      s_tmp := StringReplace(s_buffer, char(13), '', [rfReplaceAll, rfIgnoreCase]);
      if (t_regex.Exec(s_tmp)) then s_buffer := s_buffer + '='
      else s_buffer := s_buffer + '?';
      FreeAndNil(t_regex);
    end;
    memRecv.Lines.Add(format('%0.3f:<%s',[(i_tend - i_tstart)/1000, s_buffer]));
  end;
  FreeAndNil(t_cmds);
end;

procedure TFrmBootTester.txtVerifyEnter(Sender: TObject);
begin
  txtVerify.SelectAll;
end;

procedure TFrmBootTester.btnExportClick(Sender: TObject);
var
  saveDialog : TSaveDialog;    // Save dialog variable
begin
  // Create the save dialog object - assign to our save dialog variable
  saveDialog := TSaveDialog.Create(self);

  // Give the dialog a title
  saveDialog.Title := 'Export Result';

  // Set up the starting directory to be the current one
  saveDialog.InitialDir := GetCurrentDir;

  // Allow only .txt and .doc file types to be saved
  saveDialog.Filter := 'Text file|*.txt|All files|*.*';

  // Set the default extension
  saveDialog.DefaultExt := 'txt';

  // Select text files as the starting filter type
  saveDialog.FilterIndex := 1;

  // Display the open file dialog
  if saveDialog.Execute then memRecv.Lines.SaveToFile(saveDialog.FileName);

  // Free up the dialog
  saveDialog.Free;
end;
procedure TFrmBootTester.btnFileClick(Sender: TObject);
var t_fopen: TOpenDialog;
begin
  t_fopen := TOpenDialog.Create(self);
  t_fopen.Filter := 'S-Record Files (*.s, *.mot)|*.s;*.mot';
  if t_fopen.Execute then txtFile.Text := trim(t_fopen.FileName);
  FreeAndNil(t_fopen);
end;

function TFrmBootTester.BootState(): EBootState;
const
  CSTR_BOOT: string = 'BOOT?';
  CSTR_SERVICE: string = 'SERVICE';
  CSTR_APPLICATION: string = 'APPLICATION';
  CSTR_ERROR: string = 'ERROR!';
var sSend, sRecv, sTemp: string; cTimeout, tStart, tEnd: cardinal; ch: char; bRepeat: boolean;
begin
  result := BS_UNKNOWN;
  if t_ser.Active then begin
    repeat
      cTimeout := GetTickCount() + c_timeout;
      if (t_ser.ReadString(sTemp) > 0) then memRecv.Lines.Add(sTemp);

      tStart := GetTickCount();
      sSend := CSTR_BOOT + Char(13);
      t_ser.WriteString(sSend);
      while ((t_ser.TxWaiting > 0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
      tEnd := GetTickCount();
      memRecv.Lines.Add(format(CSTR_FORMAT_TO,[(tEnd - tStart)/1000.0]));
      memRecv.Lines.Add(sSend);

      tStart := GetTickCount(); sRecv := '';
      while ((t_ser.RxWaiting <= 0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
      repeat
        ch := chr(0);
        if (t_ser.ReadChar(ch) = 1) then if (not (ch = char(0))) then sRecv := sRecv + ch;
        if (t_ser.RxWaiting <= 0) then Delay(C_DELAY_MSEC);
      until ((t_ser.RxWaiting <= 0) or (GetTickCount() >= cTimeout));
      tEnd := GetTickCount();
      sTemp := UpperCase(trim(sRecv));
      memRecv.Lines.Add(format(CSTR_FORMAT_FROM,[(tEnd - tStart)/1000.0]));
      if (sRecv = '') then memRecv.Lines.Add('[empty]')
      else memRecv.Lines.Add(sRecv);

      bRepeat := false;
      if (Pos(CSTR_APPLICATION, sTemp) > 0) then result := BS_MTXAPP
      else if (Pos(CSTR_SERVICE, sTemp) > 0) then result := BS_MTXSRV
      else if (Pos(CSTR_ERROR, sTemp) > 0) then bRepeat := true
      else if (sTemp = '') then result := BS_UNKNOWN
      else result := BS_ORIGIN;
    until ((not bRepeat) or (GetTickCount() >= cTimeout));
  end;
end;

function TFrmBootTester.ExpectStr(const str: string; var sRecv: string; const msecs: cardinal): boolean;
var cTimeout: cardinal; ch: char; sTemp, sIn: string;
begin
  result := false;
  if t_ser.Active then begin
    cTimeout := GetTickCount() + msecs;
    sIn := UpperCase(str);
    while ((t_ser.RxWaiting <= 0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
    repeat
      ch := chr(0);
      if (t_ser.ReadChar(ch) = 1) then if (not (ch = char(0))) then sRecv := sRecv + ch;
      sTemp := UpperCase(sRecv);
      if (t_ser.RxWaiting <= 0) then Delay(C_DELAY_MSEC);
    until ((Pos(sIn, sTemp) > 0) or (GetTickCount() >= cTimeout));
  end;

end;

procedure TFrmBootTester.btnResetClick(Sender: TObject);
const
  CSTR_WAITING : string = 'WAITING...';
  CSTR_CHECKSUM : string = 'CHECKSUM';
  CSTR_STARTING : string = 'STARTING APPLICATION...';
  CSTR_RESET: string = 'RESET!';
  CSTR_RUN: string = 'RUN!';
  CSTR_SERVICE: string = 'service';
  CSTR_BOOT: string = 'BOOT?';
  CSTR_POWER_ONOFF: string = 'Please reset the unit using power off/on...';
var ch: char; sRecv, sSend, sTemp, sReset: string;
    bWait, bApp, bService, bReset, bResetSW: boolean;
    cTimeout, tStart, tEnd: cardinal;
    eBoot: EBootState;
begin
  if not t_ser.Active then  t_ser.Active := true;
  if t_ser.Active then begin
    cTimeout := GetTickCount() + 30000;
    if (t_ser.ReadString(sRecv) > 0) then memRecv.Lines.Add(sRecv);;

    //check boot mode
    eBoot := BootState();
    bReset := true; bResetSW := true;
    case eBoot of
      BS_UNKNOWN: begin
        bResetSW := false;
        memRecv.Lines.Add(CSTR_POWER_ONOFF);
      end;
      BS_ORIGIN: begin
        bReset := false;
        memRecv.Lines.Add('The soft reset is not supported on this unit.');
      end;
      BS_MTXSRV: begin
        if (self.cmbTo.ItemIndex = 1) then bReset := false;
        sReset := CSTR_RUN + Char(13);
      end;
      BS_MTXAPP: begin
        if (self.cmbTo.ItemIndex = 0) then bReset := false;
        sReset := CSTR_RESET + Char(13)
      end;
    end;

    if bReset then begin
      //send reset command
      if bResetSW then begin
        tStart := GetTickCount();
        t_ser.WriteString(sReset);
        while ((t_ser.TxWaiting > 0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
        tEnd := GetTickCount();
        memRecv.Lines.Add(format(CSTR_FORMAT_TO,[(tEnd - tStart)/1000.0]));
        memRecv.Lines.Add(sReset);
      end;

      //wait for the anwser from the unit
      tStart := GetTickCount(); sRecv := ''; bWait := false; bApp := false; bService := false;
      while ((t_ser.RxWaiting <= 0) and (GetTickCount() < cTimeout)) do begin
        if not bResetSW then begin
          tEnd := Round((cTimeout - GetTickCount()) / 1000);
          sTemp := format('%s %ds', [CSTR_POWER_ONOFF, tEnd]);
          memRecv.Lines[memRecv.Lines.count - 1] := sTemp;
        end;
        Delay(C_DELAY_MSEC);
      end;
      {repeat
        ch := chr(0);
        if (t_ser.ReadChar(ch) = 1) then  if (not (ch = char(0))) then sRecv := sRecv + ch;
        sTemp := UpperCase(sRecv);
        if (Pos(CSTR_WAITING, sTemp) > 0) then begin
          Delay(C_DELAY_MSEC);
          bWait := true;
          break;
        end;
        if (t_ser.RxWaiting <= 0) then Delay(C_DELAY_MSEC);
      until ((t_ser.RxWaiting <= 0) or (GetTickCount() >= cTimeout));}
      bWait := ExpectStr(CSTR_WAITING, sRecv, cTimeout - GetTickCount());
      if (t_ser.ReadString(sTemp) > 0) then sRecv := sRecv + Stemp;
      tEnd := GetTickCount();
      memRecv.Lines.Add(format(CSTR_FORMAT_FROM,[(tEnd - tStart)/1000.0]));
      memRecv.Lines.Add(sRecv);

      if (self.cmbTo.ItemIndex = 1) then begin //service mode
        Delay(100);
        if (t_ser.ReadString(sTemp) > 0) then memRecv.Lines.Add(sTemp);

        tStart := GetTickCount(); sRecv := '';
        sSend := CSTR_SERVICE + Char(13);
        t_ser.WriteString(sSend);
        while ((t_ser.TxWaiting > 0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
        tEnd := GetTickCount();
        memRecv.Lines.Add(format(CSTR_FORMAT_TO,[(tEnd - tStart)/1000.0]));
        memRecv.Lines.Add(sSend);

        tStart := GetTickCount(); sRecv := '';
        while ((t_ser.RxWaiting <=0) and (GetTickCount() < cTimeout)) do Delay(C_DELAY_MSEC);
        repeat
          ch := chr(0);
          if (t_ser.ReadChar(ch) = 1) then if (not (ch = char(0))) then sRecv := sRecv + ch;
          if (t_ser.RxWaiting <= 0) then Delay(C_DELAY_MSEC);
        until ((t_ser.RxWaiting <= 0) or (GetTickCount() >= cTimeout));
        tEnd := GetTickCount();
        memRecv.Lines.Add(format(CSTR_FORMAT_FROM,[(tEnd - tStart)/1000.0]));
        memRecv.Lines.Add(sRecv);
      end else begin//application mode
        sTemp := UpperCase(sRecv);
        if (Pos(CSTR_CHECKSUM, sTemp) > 0) then Delay(1000);
      end;

      if (t_ser.ReadString(sTemp) > 0) then memRecv.Lines.Add(sTemp);
    end;
  end;
end;

procedure TFrmBootTester.btnSendClick(Sender: TObject);
var i, n: integer; s_text: String;
begin
  if not t_ser.Active then  t_ser.Active := true;
  if t_ser.Active then
  {if not t_comport.Connected then t_comport.open();
  if t_comport.Connected then}
  begin
    s_text := trim(txtSend.Text);
    if lstSending.Items.IndexOf(s_text) < 0 then lstSending.Items.Add(s_text);

    If not TryStrToInt(txtLoop.Text, n) then n := 1;
    if n<=0 then n:= 1;
    for i := 1 to n do Transmit();
  end;

end;

procedure TFrmBootTester.btnSendFileClick(Sender: TObject);
var s_file, s_line, s_recv: string; i: integer; t_lines: TStringList; b_repeat: boolean;
begin
  if RecvStr(s_recv) > 0 then memRecv.Lines.Add(s_recv);
  s_file := trim(txtFile.Text);
  if FileExists(s_file) then begin
    t_lines := TStringList.Create;
    t_lines.LoadFromFile(s_file);
    pgbSendFile.Max := t_lines.Count;
    pgbSendFile.Position := 0;
    lblSendFile.Caption := '0%';
    if chkMetronix.Checked then begin
      for i := 0 to t_lines.Count - 1 do begin
        b_repeat := true;
        while b_repeat do begin
          t_ser.WriteString(t_lines[i] + Char(13));
          while t_ser.TxWaiting > 0 do Delay(C_DELAY_MSEC);
          pgbSendFile.Position := i + 1;
          lblSendFile.Caption := format('%d', [Round((pgbSendFile.Position / pgbSendFile.Max) * 100.0)]) + '%';
          Application.ProcessMessages();
          if (RecvStr(s_recv) > 0) then b_repeat := (RightStr(s_recv, 1) = '#')
          else b_repeat := false;
        end;
      end;
    end else begin
      for i := 0 to t_lines.Count - 1 do begin
        t_ser.WriteString(t_lines[i] + Char(13));
        while t_ser.TxWaiting > 0 do Delay(C_DELAY_MSEC);
        pgbSendFile.Position := i + 1;
        lblSendFile.Caption := format('%d', [Round((pgbSendFile.Position / pgbSendFile.Max) * 100.0)]) + '%';
        Application.ProcessMessages();
      end;
    end;
    t_lines.Clear;
    FreeAndNil(t_lines);
  end;
end;

procedure TFrmBootTester.chbRecvClick(Sender: TObject);
begin
  chbVerify.Enabled := chbRecv.Checked;
  txtVerify.Enabled := chbVerify.Checked;
end;

procedure TFrmBootTester.chbVerifyClick(Sender: TObject);
begin
  txtVerify.Enabled := chbVerify.Checked;
  if chbVerify.Checked then txtVerify.SetFocus;
end;



procedure TFrmBootTester.chkXonXoffClick(Sender: TObject);
var b_active: boolean;
begin
  b_active := t_ser.Active;
  t_ser.Active := False;
  if chkXonXoff.Checked then t_ser.FlowMode := fcXON_XOF
  else t_ser.FlowMode := fcNone;
  t_ser.Active := b_active;
end;

procedure TFrmBootTester.cmbBaudrateChange(Sender: TObject);
var b_active: boolean;
begin
  b_active := t_ser.Active;
  t_ser.Active := False;
  t_ser.Baudrate := StrToInt(cmbBaudrate.Text);
  t_ser.Active := b_active;
end;

procedure TFrmBootTester.cmbPortChange(Sender: TObject);
var b_active: boolean;
begin
  b_active := t_ser.Active;
  t_ser.Active := False;
  t_ser.Port := StrToInt(cmbPort.Text);
  t_ser.Active := b_active;
end;

procedure TFrmBootTester.FormCreate(Sender: TObject);
begin
  t_ser :=TSerial.Create(self);
  t_ser.CheckParity := false;
  t_ser.DataBits := d8Bit;
  t_ser.NotifyErrors := neNone;
  //t_ser.Name := 'Multimeter';
  t_ser.Baudrate := StrToInt(cmbBaudrate.Items[cmbBaudrate.ItemIndex]);
  t_ser.Port := StrToInt(cmbPort.Items[cmbPort.ItemIndex]);
  c_timeout := 3000;
end;

procedure TFrmBootTester.FormDestroy(Sender: TObject);
begin
  FreeAndNil(t_ser);
end;

procedure TFrmBootTester.lstSendingDblClick(Sender: TObject);
begin
  txtSend.Text := lstSending.Items[lstSending.ItemIndex]
end;

function TFrmBootTester.SendStr(const str: string): integer;
var ch: char; timeout: cardinal; sRecv: string;
begin
  timeout := GetTickCount() + c_timeout;
  if (t_ser.ReadString(sRecv) > 0) then memRecv.Lines.Add(sRecv);;

  t_ser.WriteString(str);
  repeat if (t_ser.TxWaiting > 0) then Delay(C_DELAY_MSEC);
  until ((t_ser.TxWaiting <= 0) or (GetTickCount() >= timeout));
  result := length(str);
  {result := t_comport.WriteStr(str);}
end;

function TFrmBootTester.RecvStr(var str:string): integer;
var ch: char; timeout: cardinal;
begin
  timeout := GetTickCount() + c_timeout;
  repeat if (t_ser.RxWaiting <= 0) then Delay(C_DELAY_MSEC);
  until ((t_ser.RxWaiting > 0) or (GetTickCount() >= timeout));

  str := '';
  repeat
  begin
    ch := chr(0);
    if (t_ser.ReadChar(ch) = 1) then str := str + ch
    else Delay(C_DELAY_MSEC);
  end;
  until ((t_ser.RxWaiting <= 0) or (GetTickCount() >= timeout));
  result := length(str);
  {result := t_comport.ReadStr(str,result);}
end;

end.
